
# タイムトラベル仕入れ・オークションゲーム仕様書（シンプルロジック版）

## 実装状況アップデート（2025/6/19）

✅ **フェーズ0～4完了** - 基本ゲームループ実装済み

### 実装完了項目
- Flask Webアプリケーション基盤
- 買うモード：タイムトラベルコスト計算、商品生成システム
- 売るモード：オークションシステム、AIバイヤー評価ロジック
- ゲーム管理：資金管理、ゲームオーバー判定
- 商品管理：在庫システム、出品・取消機能
- 実行環境：バッチファイル、仮想環境対応

### 実装ファイル
- `entry.py`: エントリーポイント
- `app.py`: Flaskアプリケーション（329行）
- `templates/index.html`: メインページ（166行）
- `templates/buy.html`: 買うモードUI（225行）
- `templates/sell.html`: 売るモードUI（388行）
- `run.bat`: 実行用バッチファイル
- `requirements.txt`: 依存パッケージ
- `README.md`: 使用方法とゲーム仕様

### 技術的改良点
- Jinjaテンプレート構文の適切な使用
- JSONデータ受け渡しによるJavaScriptエラー回避
- Windows環境対応（&&コマンド回避）
- 仮想環境自動セットアップ

## 仕様変更・バグ修正要求（2025/6/19 21:08）

### 🔧 買うモード：仕様変更
**現状**：`総費用 = (年数差 + 距離) × UFOサイズ倍率`
**変更後**：`総費用 = (年数差 × 距離) × UFOサイズ倍率`

**理由**：足し算から乗算への変更により、より現実的なコスト計算を実現

### 🐛 売るモード：バグ修正
**問題**：同一商品を複数のオークションスロットに重複選択可能
**修正内容**：
- 1つの商品が選択されたら、他のスロットでその商品を選択不可にする
- 商品がキャンセルされたら、再度他のスロットで選択可能にする

**実装方針**：
1. JavaScript で選択状態を管理
2. 選択済み商品のoptionを他のselectで無効化
3. 動的にoption状態を更新する仕組み

## 追加仕様変更要求（2025/6/19 21:18）

### 🎯 ゲームオーバー条件の変更
**現状**: 所持金が0円以下でゲームオーバー
**変更後**: 「所持金0円 かつ 在庫なし」でゲームオーバー

**理由**: 在庫なしで1000円持っていて1000円投資すれば商品が手に入り継続可能

### 🎲 買い物失敗システム
**新機能**: 10回に1回程度、買い物に失敗する確率を導入
- 失敗時: お金は支払うが商品は取得できない
- この場合のみ真のゲームオーバーリスクが発生

### 🔄 ページリロード確認
**新機能**: ページリロード時にゲーム状態リセット確認ダイアログを表示
- 誤操作によるゲーム状態の意図しない喪失を防止

**実装方針**：
1. app.py: ゲームオーバー判定ロジック変更
2. app.py: 買い物失敗確率システム追加
3. 全HTMLテンプレート: beforeunloadイベントでリロード確認追加

## 追加修正要求（2025/6/19 21:23）

### 🚫 ページリロード確認の削除
**問題**: ページ遷移で毎回確認UIが出て使いにくい
**対応**: beforeunloadイベントリスナーを全削除

### 🎯 レア度システムの改善
**現状**: 固定的なレア度（コモン、レア、ウルトラレア）
**変更後**: 距離と年数に応じた動的レア度システム
- 距離が遠く、昔に行くほどレア度が上がる
- レア度をfloat値で表現し、より細かい調整を可能にする

**実装方針**：
1. 全HTMLテンプレート: beforeunloadイベント削除
2. app.py: generate_item関数でレア度計算式を改善
3. 距離と年数の組み合わせでレア度倍率を動的計算

## バグ修正（2025/6/19 23:XX）

### 🐛 商品売却失敗時の消失バグ修正
**問題**: オークション売却失敗時に商品が在庫から消えてしまう
**原因**: 
- オークション設定時に商品をインベントリから削除
- 売却失敗時の在庫復元処理が欠如

**修正内容**:
1. **api/auction_api.py**: 売却失敗時の在庫復元処理を追加
   - `failed_item = game_engine.get_auction_item(result['item_id'])`
   - `game_engine.add_to_inventory([failed_item['item']])`
   - `game_engine.remove_auction_item_without_restore(result['item_id'])`

2. **core/game_engine.py**: 在庫復元なしの削除メソッドを追加
   - `remove_auction_item_without_restore()` メソッド実装

**結果**: 売却失敗時に商品が適切に在庫に戻るように修正

### 🐛 売却済み商品の選択可能バグ修正
**問題**: 部分的売却後、売却済み商品がプルダウンで再選択可能
**原因**: オークション成功後、JavaScriptで売却済み商品のオプションが削除されていない

**修正内容**:
1. **templates/sell.html**: 売却成功時にプルダウンからオプション削除
   - `select.removeChild(select.options[j])` で該当商品を全プルダウンから削除
   - 在庫数表示の動的更新処理を追加

**結果**: 売却済み商品が再選択不可になり、UIの整合性が向上

### 🔧 AIバイヤー入札ロジック改善
**問題**: AIバイヤーの入札閾値が高すぎて商品が売れない
**原因**: 
- 入札閾値が0.8と高すぎる設定
- デバッグ情報の不足で問題特定が困難

**修正内容**:
1. **core/auction_system.py**: 入札閾値を0.8→0.3に下げる
2. **core/ai_buyers.py**: AIバイヤーのデフォルト閾値も0.3に変更
3. **core/auction_system.py**: 詳細デバッグログ追加
   - ジャンル別バイヤー統計表示
   - 各バイヤーの興味度計算結果表示
   - 価値/価格比の表示

**結果**: AIバイヤーがより積極的に入札し、オークションが活発化

### 🔄 AIバイヤー動的入れ替えシステム
**問題**: 固定バイヤーでは特定ジャンルに興味0の場合売れ残りが発生
**原因**: 同じバイヤーが継続使用され、興味のないジャンルが必ず存在

**修正内容**:
1. **core/auction_system.py**: オークション開始時にバイヤー新規生成
   - `ai_buyer_manager.initialize_buyers()` をオークション毎に実行
2. **core/ai_buyers.py**: バイヤー生成ロジック改善
   - バイヤー数を10→15人に増加
   - 全ジャンルを必ずカバーする生成アルゴリズム
   - パラメータ範囲拡大で多様性向上

**実装詳細**:
- 最初の各ジャンル分のバイヤーは該当ジャンルを必ず含む
- 残りのバイヤーは完全ランダム（2-4ジャンル）
- パラメータ範囲: condition(0.3-1.2), rarity(0.6-1.8), price(0.3-1.5)

**結果**: 全ジャンルで売れ残りリスクが大幅減少、オークション活性化

## リファクタリング計画（2025/6/19 21:38）

### 🏗️ アーキテクチャ分離
**目標**: ゲームロジックと表示を明確に分離し、UI仕様の置き換えを容易にする

#### ファイル分割計画（500行制限対応）
```
timetravel/
├── core/                    # ゲームロジック層
│   ├── game_engine.py      # ゲーム状態管理（<400行）
│   ├── item_system.py      # 商品システム（<400行）
│   ├── auction_system.py   # オークションシステム（<400行）
│   └── ai_buyers.py        # AIバイヤーロジック（<400行）
├── api/                     # API層（JSON入出力）
│   ├── game_api.py         # ゲーム状態API（<400行）
│   ├── travel_api.py       # タイムトラベルAPI（<400行）
│   └── auction_api.py      # オークションAPI（<400行）
├── web/                     # Web UI層
│   ├── app.py              # Flask エントリーポイント（<400行）
│   └── templates/          # HTMLテンプレート
└── cli/                     # CLI UI層（将来拡張）
    └── game_cli.py         # コマンドライン版
```

#### JSON API設計
- **ゲーム状態**: `GET /api/game/state` → ゲーム状況をJSON返却
- **タイムトラベル**: `POST /api/travel` → 購入パラメータ受信、結果JSON返却
- **オークション**: `POST /api/auction/start` → 出品情報受信、結果JSON返却

#### オークション詳細ログ機能
- Python側で各入札をprintし、バランス調整用の詳細情報を提供
- 入札者、商品、価格変動、結果などをリアルタイム出力

### 📋 実装ステップ
1. **core/game_engine.py**: ゲーム状態管理クラス作成
2. **core/item_system.py**: 商品生成・管理システム
3. **core/auction_system.py**: オークションロジック（ログ付き）
4. **api/**: JSON API層実装
5. **web/app.py**: 既存Flaskアプリを薄いラッパーに変更

---

## 概要

このゲームは、プレイヤーが限られた元金を使って過去にタイムトラベルし、物品を仕入れて現代のメルカリ風オークションで売却し、利益を得ることを目的とする。  
まずはゲーム性とそのサイクルの実証までを目指す。
この仕様は、フレーバー（文脈や演出）を排除し、純粋なロジックの構築にフォーカスするものである。


///
コーディングのルールとして、１ファイル約400行程度にして。それ以上は分割を。

UIは将来リッチな方法で実装したいが、当面はflaskでwebブラウザで実装する。
以下をpython処理のエントリとして、実行できるbatを生成する。ローカルサーバーをpythonで起動してhtmlを開かせて。
C:\work\script\timetravel\entry.py

ただし以下の仮想環境を使用し、必要なものは確認を行ってinstallする。
C:\work\script\timetravel\venv
上記をgitignoreに追記して。

installが必要なものはいかに追記する。
requirements.txt

さらに実装したものを使わせるための仕様は常に以下を更新して。
README.md

また、制作仕様が変わったり、実装経緯に関しては常にこの文書を更新して。

&&などwindows環境で使用できないコマンドを使わないように。
---

## 1. ゲーム初期状態

- プレイヤーの元金：1000円
- プレイヤーは「買う」または「売る」モードを選択できる
- お金が0円以下になるとゲームオーバー

---

## 2. 「買う」モード

### 入力パラメータ（プレイヤーが指定）

- **年数差（int）**：現代から何年前に行くか。1年 = 1円
- **距離（int）**：東京を中心とした移動距離（km）。1km = 1円
- **UFOサイズ倍率（float）**：1.0～100.0倍。総コストに乗算される

### 費用計算

```
総費用 = (年数差 + 距離) × UFOサイズ倍率
```

### 仕入れ処理

- UFOのサイズに応じて、複数個の物品を取得
- 各物品は以下の情報を持つ：

| 属性 | 内容 |
|------|------|
| ジャンル | カテゴリ（例：家電、玩具、服飾など） |
ジャンルは約10個、先に適当に作ってハードコードしておいて使って。

| 状態 | ランダム or 年代に応じて（A:新品、B:良品、C:劣化） |
| 希少性 | コモン、レア、ウルトラレアなど（ランダム／年代依存） |

※それぞれが数値を持っていて乗算値が潜在的な価格になる。

---

## 3. 「売る」モード

### プレイヤーの操作

- 所有物品の中から出品物を選択
- 出品できる最大数は８個まで。
- 販売価格（開始価格）を設定
- オークションを1分間シミュレート

### プレイヤーの操作　UIと詳細
- とりあえず、テーブルのようなUIで表現して。機能的な演出のないもので良い。
- A 出品物、B 開始価格、C 入札数、D 現在価格。の四つの表示。また出品のボタンで1分間のオークション開始。
- A 出品物、B 開始価格、この二つが操作できる。出品物は在庫からの選択と、取り消しで空にもできる。
- 取り消ししたものは在庫に戻る。オークション中は開始価格を変えられないが、再出品すれば再設定できる。
- 1分間は再出品してもリセットされない。開始を押すと、全体に対して1分間オークションの処理がされるのみ。


### 販売ロジック

- AIの入札者が複数存在
- 各AIは以下の評価関数により、商品に対する興味度を決定

```
興味度 = f(ジャンル, 希少性, 状態, 値付け)
```

- 興味度が閾値を超える場合、入札で購入される
- 入札時に適当に高値をつけ、1分間のタイムアップまで更新され続ける。
- 価格が高すぎる場合は無視される
- 販売成功時：
    - 手数料（例：10%）を引いて売却益を得る
- 販売失敗時：
    - 商品はそのまま出品状態で残る（価格を変えたり、再出品可）
---

## 4. オークションAIのシンプルモデル（初期段階）

- AIの属性：好みのジャンル、の中で　状態と希少性への関心度
- 行動：商品が許容価格内なら入札、即決条件に一致すれば即購入

※オークションAIはそれぞれ複数のジャンルをListとして持つ。商品のジャンルが一致すると興味を持つ。
---

## 5. 今後の拡張想定（まだ行わない）

- LLMを導入して、フレーバーをいれたい
- 商品名・説明文をLLMで生成（ユニークな個体化）
- 買い手AIの興味・行動をプロンプトベースで構築
- オークション時のコメント・評価なども自然文で生成

---

## 6. フェーズ分割実装指針（開発者向け）

0. **フェーズ0**：仮のUIをpythonとflaskで作り、実行させるbatを作って起動確認
1. **フェーズ1**：買うモードのコスト計算と商品生成ロジック
2. **フェーズ2**：売るモードの価格評価とオークション結果判定
3. **フェーズ3**：収益・資金管理とループ処理
4. **フェーズ4**：商品保持・再出品ロジック

まずここまでをめざそう

5. **フェーズ5**：LLM導入準備のための商品構造設計とコメント処理フック
6. **フェーズ6**：pyxelなどを利用してインターフェースをよくする。
---
